// ut_bitfield.cpp

#include <algorithm>    //  std::find_if
#include <cassert>      //  assert
#include <cstdlib>      //  exit(), EXIT_FAILURE
#include <iostream>     //  for sending text to stdout, stderr
#include <sstream>      //  std::stringstream, std::string

#include "bitfield.h"

// ============ helper debug functions ================================
void print_vac_state( std::uint16_t val)
{
    switch ( val )
    {
        case 0: std::cout << "de-energized" <<  ")" << std::endl; break;
        case 1: std::cout << "energized"    <<  ")" << std::endl; break;
        default:
            {
                std::cout   << "solenoid bitfield contains impossible value  (" << val << "). "
                            << std::endl;
                assert (!"solenoid bitfield contains impossible value");
            }
        break;
    }
}

//-----------------------------------------------------
// print_reg() --   prints state of the 'register' to stdout
//
//                  For this function to work correctly in
//                  real life the 'register' will need to
//                  be R/W, not just write-only

void print_reg(struct genpurpIO_register* reg)
{
    std::cout << "reg value (raw bits)" << reg->energize_vac_solenoid2  << std::endl;
    std::cout << "reg value (raw bits)" << reg->energize_vac_solenoid3  << std::endl;
    std::cout << "reg value (raw bits)" << reg->floodlight_pwr  << std::endl;

    std::cout << "vac_solenoid2 state:(";
    print_vac_state( reg->energize_vac_solenoid2 );

    std::cout << "vac_solenoid3 state:(";
    print_vac_state( reg->energize_vac_solenoid3 );

    std::cout << "flood light pwr setting:(" << reg->floodlight_pwr << ")" << std::endl << std::endl;
}

// deliberately_throw_exception() is not part of the unit test suite
// it's purpose, when used, is to verify that the unit test's
// handling of unexpected exceptions is working correctly
//
int deliberately_throw_exception()
{
    std::string utid( __func__ );

    // init to failure. Shouldn't matter unless exception fails to fire
    int something_failed = 1;

    std::cout << utid << ": ";

    throw std::logic_error("this is a logic_error exception.");

    return something_failed;
}


// ============ end of helper debug functions ================================

const std::size_t ok_col_pos   { 95 };  // column position for "ok" text   See note1

// rtrim() -- toss trailing dots from end of a string
//
// credits: https://stackoverflow.com/a/217605
static inline void rtrim(std::string &s)
{
    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch)
            {
                return ch != '.';
            }
        ).base(), s.end()
    );
}


// note1:   for readablity I favor formatting UT chatter
//          in text columns. Generally the first column is
//          a description of what the given UT is testing and
//          the second column shows that the test passed (e.g., "ok").
//
//          The text emitted when a UT fails is formatted differently
//          WRT chatter from a successful UT. Put another way,
//          a UT failure emits text that visually clashes with
//          the text generated by successful UTs.
//
//          The human eyes is a mismatch detector.  This formatting
//          scheme intends to make a stream of successful UTs
//          "blend together" and any UT failures to visually clash
//          with the chatter from sucessful UTs. The visual clash will
//          cause any UT failure to be instantly noticed.
//
//  note4:  As per note1, we are inserting the "ok" text in a
//          second 'column' on the line.  We're using insert() to
//          create a "tab stop" effect where the second 'column' is
//          located.
//
//          This column's location follows the chatter about what the
//          given UT is testing. This "tab stop" is located beyond the
//          end of the chatter about what a given UT is testing.
//
//          string.insert(pos, text) will throw out_of_range if
//          pos > string length.
//
//          Consequently, we are padding the end of the first column's
//          chatter with dots so as to prevent string.insert()
//          from throwing "out_of_range" when we insert "ok" at
//          the second column's "tab stop".
//
//          I am padding with dots instead of whitespace because
//          the row of dots guide the viewer's eyes from the
//          text to the corresponding "ok"|"FAILED!" indication.


// ut_verify_solenoid_state() general purpose UT boilerplate for
// unit testing the functor that returns the current state of a solenoid
//
// keeping it DRY
int ut_verify_solenoid_state(
                                const std::string& utid,        // ut17, ut18, etc.
                                const std::string& intent,      // what UT is attempting to verify
                                const vacuum actual_state,      // solenoid's actual state
                                const vacuum expected_state     // solenoid's expected state
                            )
{
    int something_failed = 1;    // init to UT failure
    std::stringstream ut_intent {};

    const std::string str_actual_state   { (actual_state   == vacuum::ON ? "vacuum::ON" : "vacuum::OFF") };
    const std::string str_expected_state { (expected_state == vacuum::ON ? "vacuum::ON" : "vacuum::OFF") };

    ut_intent <<  intent;

    std::cout << utid << ": ";

    // if the code worked as expected
    if (actual_state == expected_state)
    {
        something_failed = 0; // indicate UT passed
    }

    if (something_failed)
    {
        std::cout << "FAILED!" << std::endl;
        std::cout << ut_intent.str() << std::endl;
        std::cout << "expected("    << str_expected_state << ")" << std::endl;
        std::cout << "encountered(" << str_actual_state   << ")" << std::endl;
    }
    else
    {
        //  format "UT Passed" chatter. See note1

        ut_intent <<  "......................................................";   // note4
        std::string tmp { ut_intent.str()  };
        tmp.insert( ok_col_pos, "ok" );     // columnize "ok" text   See note1
        rtrim(tmp);                         // toss trailing dots
        std::cout << tmp << std::endl;
    }

    return something_failed;
}


// ut_verify_lamp_state() general purpose UT boilerplate for
// unit testing the functor that returns the current state of floodlamp
//
// keeping it DRY
int ut_verify_lamp_state(
                            const std::string& utid,               // ut17, ut18, etc.
                            const std::string& intent,             // what UT is attempting to verify
                            const std::uint16_t actual_settings,   // flood lamp's actual state
                            const std::uint16_t expected_settings  // flood lamp's expected state
                        )
{
    int something_failed = 1;    // init to UT failure
    std::stringstream ut_intent {};

    ut_intent <<  intent;

    std::cout << utid << ": ";

    // if the code worked as expected
    if (actual_settings == expected_settings)
    {
        something_failed = 0; // indicate UT passed
    }

    if (something_failed)
    {
        std::cout << "FAILED!" << std::endl;
        std::cout << ut_intent.str() << std::endl;
        std::cout << "expected("    << actual_settings << ")" << std::endl;
        std::cout << "encountered(" << expected_settings   << ")" << std::endl;
    }
    else
    {
        //  format "UT Passed" chatter. See note1

        ut_intent <<  "......................................................";   // note4
        std::string tmp { ut_intent.str()  };
        tmp.insert( ok_col_pos, "ok" );     // columnize "ok" text   See note1
        rtrim(tmp);                         // toss trailing dots
        std::cout << tmp << std::endl;
    }

    return something_failed;
}

//======================= Unit Tests Begin ======================================
//
// verify that the ctor set solenoid2 to vacuum:OFF
int ut00()
{
    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling vacuum solenoid #2
    set_bits< struct genpurpIO_register*, solenoid2_t, vacuum   > vac_solenoid2{ &mock_reg84 };

    std::string ut_intent {  "verifing that the ctor initialized solenoid2 to vacuum:OFF" };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    return ut_verify_solenoid_state(
                                        std::string { __func__ }, // utid,
                                        ut_intent,                // what UT is attempting to verify
                                        vac_solenoid2(),          // solenoid's actual state
                                        vacuum::OFF               // solenoid's expected state
                                   );
}

// verify that the ctor set solenoid3 to vacuum:OFF
int ut01()
{
    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // This is masquerading as a 16 bit "register"

    // create functor for controlling vacuum solenoid #3
    set_bits< struct genpurpIO_register*, solenoid3_t, vacuum   > vac_solenoid3{ &mock_reg84 };

    std::string ut_intent {  "verifing that the ctor initialized solenoid3 to vacuum:OFF" };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    return ut_verify_solenoid_state(
                                        std::string { __func__ }, // utid,
                                        ut_intent,                // what UT is attempting to verify
                                        vac_solenoid3(),          // solenoid's actual state
                                        vacuum::OFF               // solenoid's expected state
                                   );
}


// verify that the ctor sets the floodlamp to LIGHTS_OUT
int ut02()
{
    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling floodlamp #42. ctor initializes the floodlamp to LIGHTS_OUT
    set_bits< struct genpurpIO_register*, floodlight_t, floodlight_t > flood_light42{ &mock_reg84 }; // for lamp #42

    std::string ut_intent {  "verifing that the ctor initialized floodlamp to LIGHTS_OUT" };

    return ut_verify_lamp_state(
                                    std::string { __func__ },   // utid,
                                    ut_intent,                  // what UT is attempting to verify
                                    flood_light42(),            // flood lamp's actual settings
                                    LIGHTS_OUT                  // flood lamp's expected settings
                               );
}

// verify that the solenoid2's functor can energize solenoid2
int ut03()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling vacuum solenoid #2
    set_bits< struct genpurpIO_register*, solenoid2_t, vacuum   > vac_solenoid2{ &mock_reg84 };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the solenoid2's functor can return solenoid state prior to the functor call" };

        // note1: The functor both:
        //      1) sets the solenoid to a new state; and
        //      2) returns the solenoid's state that existed prior to calling the functor.
        //
        // note2: the solenoid's expected state prior to the functor call.
        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ },   // utid,
                                                            ut_intent,                  // what UT is attempting to verify
                                                            vac_solenoid2(vacuum::ON),  // note1
                                                            vacuum::OFF                 // note2
                                                    );
    }

    {
        std::string ut_intent {  "verifing that the solenoid2's functor can energize solenoid2" };

        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ }, // utid,
                                                            ut_intent,                // what UT is attempting to verify
                                                            vac_solenoid2(),          // solenoid's actual state
                                                            vacuum::ON               // solenoid's expected state
                                                    );
    }

    return something_failed;
}


// verify that the solenoid3's functor can energize solenoid3
int ut04()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling vacuum solenoid #3
    set_bits< struct genpurpIO_register*, solenoid3_t, vacuum   > vac_solenoid3{ &mock_reg84 };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the solenoid3's functor can return solenoid state prior to the functor call" };

        // note1: The functor both:
        //      1) sets the solenoid to a new state; and
        //      2) returns the solenoid's state that existed prior to calling the functor.
        //
        // note2: the solenoid's expected state prior to the functor call.
        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ },   // utid,
                                                            ut_intent,                  // what UT is attempting to verify
                                                            vac_solenoid3(vacuum::ON),  // note1
                                                            vacuum::OFF                 // note2
                                                    );
    }

    {
        std::string ut_intent {  "verifing that the solenoid3's functor can energize solenoid3" };

        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ }, // utid,
                                                            ut_intent,                // what UT is attempting to verify
                                                            vac_solenoid3(),          // solenoid's actual state
                                                            vacuum::ON                // solenoid's expected state
                                                    );
    }

    return something_failed;
}

// verify that the solenoid2's functor can de-energize solenoid2
int ut05()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling vacuum solenoid #2
    set_bits< struct genpurpIO_register*, solenoid2_t, vacuum   > vac_solenoid2{ &mock_reg84 };

    vac_solenoid2(vacuum::ON);

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the solenoid2's functor can return solenoid state prior to the functor call" };

        // note1: The functor both:
        //      1) sets the solenoid to a new state; and
        //      2) returns the solenoid's state that existed prior to calling the functor.
        //
        // note2: the solenoid's expected state prior to the functor call.
        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ },   // utid,
                                                            ut_intent,                  // what UT is attempting to verify
                                                            vac_solenoid2(vacuum::OFF), // note1
                                                            vacuum::ON                  // note2
                                                    );
    }

    {
        std::string ut_intent {  "verifing that the solenoid2's functor can de-energize solenoid2" };

        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ }, // utid,
                                                            ut_intent,                // what UT is attempting to verify
                                                            vac_solenoid2(),          // solenoid's actual state
                                                            vacuum::OFF               // solenoid's expected state
                                                    );
    }

    return something_failed;
}


// verify that the solenoid3's functor can de-energize solenoid3
int ut06()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling vacuum solenoid #3
    set_bits< struct genpurpIO_register*, solenoid3_t, vacuum > vac_solenoid3{ &mock_reg84 };

    vac_solenoid3(vacuum::ON);

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the solenoid3's functor can return solenoid state prior to the functor call" };

        // note1: The functor both:
        //      1) sets the solenoid to a new state; and
        //      2) returns the solenoid's state that existed prior to calling the functor.
        //
        // note2: the solenoid's expected state prior to the functor call.
        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ },   // utid,
                                                            ut_intent,                  // what UT is attempting to verify
                                                            vac_solenoid3(vacuum::OFF), // note1
                                                            vacuum::ON                  // note2
                                                    );
    }

    {
        std::string ut_intent {  "verifing that the solenoid3's functor can de-energize solenoid3" };

        something_failed += ut_verify_solenoid_state(
                                                            std::string { __func__ }, // utid,
                                                            ut_intent,                // what UT is attempting to verify
                                                            vac_solenoid3(),          // solenoid's actual state
                                                            vacuum::OFF                // solenoid's expected state
                                                    );
    }

    return something_failed;
}


// verify that the floodlamp's functor can set power-level
int ut07()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling floodlamp #42
    set_bits< struct genpurpIO_register*, floodlight_t, floodlight_t > flood_light42{ &mock_reg84 };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the floodlamp's functor can return solenoid state prior to the functor call" };

        // note1: The functor both:
        //      1) sets the floodlamp's power setting to a new setting
        //      2) returns the floodlamp's power setting that existed prior to calling the functor.
        //
        // note2: the floodlamp's expected power setting prior to the functor call.
        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ },         // utid,
                                                    ut_intent,                        // what UT is attempting to verify
                                                    flood_light42(FULL_ILLUMINATION), // all bits set to 1
                                                    LIGHTS_OUT                        // note2
                                                );
    }

    {
        std::string ut_intent {  "verifing that functor can set the floodlamp to max power" };

        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ }, // utid,
                                                    ut_intent,                // what UT is attempting to verify
                                                    flood_light42(),          // obtain power setting
                                                    FULL_ILLUMINATION         // note2
                                                );
    }

    return something_failed;
}


// verify that the floodlamp's functor can set power-level
int ut08()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling floodlamp #42
    set_bits< struct genpurpIO_register*, floodlight_t, floodlight_t > flood_light42{ &mock_reg84 };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the floodlamp's functor can return floodlamp state prior to the functor call" };

        flood_light42(FULL_ILLUMINATION), // precondition: full power

        // note1: The functor both:
        //      1) sets the floodlamp's power setting to a new setting.
        //         the next few unit tests will conduct walking 1's testing
        //      2) returns the floodlamp's power setting that existed prior to calling the functor.
        //
        // note2: the floodlamp's expected power setting prior to the functor call.
        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ },     // utid,
                                                    ut_intent,                    // what UT is attempting to verify
                                                    flood_light42(BRIGHT_LIGHTS), // walking 1's testing. note1
                                                    FULL_ILLUMINATION             // note2
                                                );
    }

    {
        std::string ut_intent {  "Walking 1's testing. power bit pattern == 0B100" };

        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ }, // utid,
                                                    ut_intent,                // what UT is attempting to verify
                                                    flood_light42(),          // obtain power setting
                                                    BRIGHT_LIGHTS             // note2
                                                );
    }

    return something_failed;
}


// verify that the floodlamp's functor can set power-level
int ut09()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling floodlamp #42
    set_bits< struct genpurpIO_register*, floodlight_t, floodlight_t > flood_light42{ &mock_reg84 };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the floodlamp's functor can return floodlamp state prior to the functor call" };

        flood_light42(BRIGHT_LIGHTS), // precondition: power setting bit pattern == 0B100

        // note1: The functor both:
        //      1) sets the floodlamp's power setting to a new setting.
        //         the next few unit tests will conduct walking 1's testing
        //      2) returns the floodlamp's power setting that existed prior to calling the functor.
        //
        // note2: the floodlamp's expected power setting prior to the functor call.
        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ },     // utid,
                                                    ut_intent,                    // what UT is attempting to verify
                                                    flood_light42(MOOD_LIGHTING), // walking 1's testing. note1
                                                    BRIGHT_LIGHTS                 // note2
                                                );
    }

    {
        std::string ut_intent {  "Walking 1's testing. power bit pattern == 0B010" };

        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ }, // utid,
                                                    ut_intent,                // what UT is attempting to verify
                                                    flood_light42(),          // obtain power setting
                                                    MOOD_LIGHTING             // note2
                                                );
    }

    return something_failed;
}


// verify that the floodlamp's functor can set power-level
int ut10()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling floodlamp #42
    set_bits< struct genpurpIO_register*, floodlight_t, floodlight_t > flood_light42{ &mock_reg84 };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the floodlamp's functor can return floodlamp state prior to the functor call" };

        flood_light42(MOOD_LIGHTING), // precondition: power setting bit pattern == 0B010

        // note1: The functor both:
        //      1) sets the floodlamp's power setting to a new setting.
        //         the next few unit tests will conduct walking 1's testing
        //      2) returns the floodlamp's power setting that existed prior to calling the functor.
        //
        // note2: the floodlamp's expected power setting prior to the functor call.
        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ },       // utid,
                                                    ut_intent,                      // what UT is attempting to verify
                                                    flood_light42(VERY_DIM_LIGHTS), // walking 1's testing. note1
                                                    MOOD_LIGHTING                   // note2
                                                );
    }

    {
        std::string ut_intent {  "Walking 1's testing. power bit pattern == 0B001" };

        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ }, // utid,
                                                    ut_intent,                // what UT is attempting to verify
                                                    flood_light42(),          // obtain power setting
                                                    VERY_DIM_LIGHTS           // note2
                                                );
    }

    return something_failed;
}


// verify that the floodlamp's functor can set power-level
int ut11()
{
    int something_failed = 0;

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling floodlamp #42
    set_bits< struct genpurpIO_register*, floodlight_t, floodlight_t > flood_light42{ &mock_reg84 };

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    {
        std::string ut_intent {  "verifing that the floodlamp's functor can return floodlamp state prior to the functor call" };

        flood_light42(VERY_DIM_LIGHTS), // precondition: power setting bit pattern == 0B010

        // note1: The functor both:
        //      1) sets the floodlamp's power setting to a new setting.
        //         the next few unit tests will conduct walking 1's testing
        //      2) returns the floodlamp's power setting that existed prior to calling the functor.
        //
        // note2: the floodlamp's expected power setting prior to the functor call.
        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ },  // utid,
                                                    ut_intent,                 // what UT is attempting to verify
                                                    flood_light42(LIGHTS_OUT), // walking 1's testing. note1
                                                    VERY_DIM_LIGHTS            // note2
                                                );
    }

    {
        std::string ut_intent {  "Verify that functor can remove power from floodlamp" };

        something_failed += ut_verify_lamp_state(
                                                    std::string { __func__ }, // utid,
                                                    ut_intent,                // what UT is attempting to verify
                                                    flood_light42(),          // obtain power setting
                                                    LIGHTS_OUT                // note2
                                                );
    }

    return something_failed;
}

// verify that Floodlamp's functor correctly throws 'Out of Range' exception
int ut12()
{
    int something_failed = 0;    // init to UT passing

    //------------------------------------------------------------
    //
    // setup for unit test
    //
    static struct genpurpIO_register mock_reg84;   // mock_reg84 is masquerading as a 16 bit "register"

    // create functor for controlling floodlamp #42
    set_bits< struct genpurpIO_register*, floodlight_t, floodlight_t > flood_light42{ &mock_reg84 };


    std::stringstream ut_intent {};
    ut_intent <<  "Verifing floodlamp throws 'Out of Range' exception.";
    ut_intent <<  "......................................................";   // note4

    //------------------------------------------------------------
    //
    // conduct unit test
    //

    std::cout << std::string { __func__ } << ": ";  // output utid to stdout

    try
    {
        // attempt to set floodlamp power level beyond max possible power settings.
        flood_light42(FLOODLIGHT_OOR); // should throw out of range exception here

        // still here? Then the functor failed to throw an Out Of Range exception
        something_failed = 1;    // indicate UT failure

        std::string tmp { ut_intent.str()  };
        tmp.insert( ok_col_pos, "FAILED!" );    // columnize "FAILED!" text   See note1
        rtrim(tmp);                             // toss trailing dots
        std::cout << tmp << std::endl;
    }
    catch (std::range_error & e)
    {
        // if we are here then the floodlamp functor successfully
        // threw a std::range_error when it was passed an illegal power level

        something_failed = 0;    // indicate UT passed

        std::string tmp { ut_intent.str()  };
        tmp.insert( ok_col_pos, "ok" );     // columnize "ok" text   See note1
        rtrim(tmp);                         // toss trailing dots
        std::cout << tmp << std::endl;

        //-------------------------------------------------------------------
        //
        // now verify that the exception's message is as expected
        //
        std::cout << std::string { __func__ } << ": ";  // output utid to stdout

        ut_intent.str("");      // reset to empty string
        ut_intent <<  "Verifing 'Out of Range' exception's error message is as expected.";
        ut_intent <<  "...............................................................";   // note4

        tmp.clear();            // reset to empty string
        tmp = ut_intent.str();

        std::string expected_except_msg {"Incorrect attempt to set floodlight #42 pwr value to (8). "
                                         "Valid pwr settings range for floodlight #42 is 0:7. "};

        // if the exception's message is as expected.
        if ( e.what() == expected_except_msg)
        {
            // then this test passed

            tmp.insert( ok_col_pos, "ok" );     // columnize "ok" text   See note1
            rtrim(tmp);                         // toss trailing dots
            std::cout << tmp << std::endl;
        }
        else // the msg was something other than what we expected.
        {
            something_failed += 1;    // indicate UT failure

            tmp.insert( ok_col_pos, "FAILED!" ); // columnize "FAILED!" text   See note1
            rtrim(tmp);                          // toss trailing dots
            std::cout << tmp << std::endl;
            std::cout << "incorrect exception message: (" << e.what()               << ")" << std::endl;
            std::cout << "expected exception message: ("  << expected_except_msg    << ")" << std::endl;
        }
    }

    return something_failed;
}

//-----------------------------------------------------

int main( int argc, char * argv[] )
{
    bool something_failed = false;

    try
    {
        //something_failed += deliberately_throw_exception();
        //
        //-------------------------------------------------------------
        //
        // UT ctor
        //
        something_failed += ut00();     // verify that the ctor sets solenoid2 to vacuum:OFF
        something_failed += ut01();     // verify that the ctor sets solenoid3 to vacuum:OFF
        something_failed += ut02();     // verify that the ctor sets floodlamp to LIGHTS_OUT
        //
        //-------------------------------------------------------------
        //
        // UT solenoid functors
        //
        something_failed += ut03();     // verify solenoid2's functor
        something_failed += ut04();     // verify solenoid3's functor
        something_failed += ut05();     // verify solenoid2's functor
        something_failed += ut06();     // verify solenoid3's functor
        //
        //-------------------------------------------------------------
        //
        // Floodlamp functors
        //
        something_failed += ut07();     // verify floodlamp's functor can set floodlamp to max power
        something_failed += ut08();     // walking 1's testing: floodlamp's power-level == 100
        something_failed += ut09();     // walking 1's testing: floodlamp's power-level == 010
        something_failed += ut10();     // walking 1's testing: floodlamp's power-level == 001
        something_failed += ut11();     // verify floodlamp's functor remove power from floodlamp
        //
        //-------------------------------------------------------------
        //
        // Floodlamp Out of range exception
        //
        something_failed += ut12();     // Floodlamp Out of range exception

    }
    catch (std::exception& e)
    {
        std::cerr << std::endl << "UNEXPECTED exception thrown: " << e.what() << std::endl << std::endl; // sent to console
        std::cout << std::endl << "UNEXPECTED exception thrown: " << e.what() << std::endl << std::endl; // sent to bitfield_ut_output.txt
        something_failed = 1;
    }

    if ( something_failed )
    {
        // note3:   One of the desired affects of a UT failure to
        //          "break the build". In this way UT failures
        //          cannot be ignored.
        //
        //          make aborts processing a Makefile wherever one of the
        //          Makefile's recipes terminates with non-zero exit status.
        //
        //          Consequently, this app must terminate with a
        //          non-zero exit status when any unit if its tests fail
        //          so as to break the build on UT failure.
        //
        std::cerr << std::endl << "UNIT TEST FAILED!" << std::endl;  // sent to the console
        std::cout << std::endl << "UNIT TEST FAILED!" << std::endl;  // sent to bitfield_ut_output.txt
        exit(EXIT_FAILURE);   // note3
    }
    else
    {
        std::cout << std::endl << "UNIT TEST passed!" << std::endl;
    }

    return 0;
}

